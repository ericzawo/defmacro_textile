---
layout: post
title: Software engineering, lessons learned
wip: true
---

h1. {{ page.title }}

p(meta). 04 Apr 2013

Over the course of building RethinkDB we learned many lessons. Some are rediscovered platitudes, and some are unique. In this post, I will maintain a list of lessons learned about the art and craft of software engineering.

h3. Fight complexity with all you've got

Linear increases in complexity cause superlinear increases in amount of work to be done. Be careless about complexity, and before you know it your development process will crawl to a halt.

That one engineer you hired to create a new component? Every time it has a bug, it will undoubtedly interact with other components and take up the time of other developers. That API you made slightly more complicated to solve an edge case for a potential (read: imaginary) future customer? Other people will have to spend time learning it, and will inevitably introduce bugs because they misunderstand it (which someone, of course, will have to spend time fixing).

Complexity increases the surface area of your project. In software engineering, large surface area is death. Fight, fight, fight complexity with everything you've got. If you can avoid adding new functionality, fight like hell to keep it out. If you lose that fight, see if you can get 80% of the functionality with 20% of the work. Usually, you can. Fight like hell to do it that way. If you lose _this_ fight, either you've hit the one case in a thousand where complexity is warranted, or, more likely, you should have fought harder.

h3. Instill shared culture

Sooner or later you'll discover you've hired engineers on your team that have very different philosophies on how software should be built. Say, a C programmer, and a C++ programmer. The former will want the codebase to look like the Linux kernel. The latter will want it to look like the boost MPL library. After observing a few squabbling sessions, you'll be faced with three progressively more unpleasant options:

# Pick _The One True Way_ and enforce it everywhere.
# Explicitly give everyone freedom to write code the way they wish.
# Do nothing whatsoever.

The first choice is very unpleasant, especially early on. You'll make some people very unhappy. You'll have to repeatedly say *no*, often to very frustrated people, and often when its least convenient. It's difficult, emotionally draining, and often downright confrontational. It's especially hard if you're the type of person who doesn't like to rock the boat. But it's the only way to grow a cohesive team.

On the surface, the second choice seems easy and effective. It makes sense to ask people to let others code the way they like. Everybody can understand that. It also appears effective. Give the C programmer their gotos and the C++ programmer their templates, and they'll work at peak efficiency. But in practice a heterogeneous codebase in a small team is a disaster. People run into each other's code far more often than one would think. That means constantly stepping on each other's toes and getting bogged down by learning a plethora of drastically different coding styles.

The last choice is the worst of all worls. It combines the ineffectiveness of a heterogeneous codebase with the stressfulness of constant arguments and bikeshedding. In the long run, it's also the most painful (not in the least because your project isn't getting anywhere).

I've tried all three and I will _always_ pick the first choice when managing small teams. It can be unpleasant early on, but it's the only way to build a team that's both happy _and_ productive. Always, always, always fight to cultivate and enforce shared culture.

h3. Sprints, deadlines, and estimates

This is _really_ important. Say something about this here.

h3. Code review everything

It helps a lot.

h3. Never do large rewrites

It kills you.

h3. Test less code more often

As opposed to more code less often.