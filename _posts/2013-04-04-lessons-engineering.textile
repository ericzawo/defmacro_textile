---
layout: post
title: Software engineering, lessons learned
wip: true
---

h1. {{ page.title }}

p(meta). 04 Apr 2013

Over the course of building "RethinkDB":www.rethinkdb.com we learned many lessons. Some are rediscovered platitudes, and some are unique. In this post, I will maintain a list of lessons learned about the art and craft of software engineering.

h3. Instill shared culture

Sooner or later you'll discover you've hired engineers on your team that have very different philosophies on how software should be built. Say, a C programmer, and a C++ programmer. The former will want the codebase to look like the Linux kernel. The latter will want it to look like the boost MPL library. After observing a few squabbling sessions, you'll be faced with three progressively more unpleasant options:

I've tried all possible ways of addressing the ensuing social issues (including doing nothing), and found that there is only one approach that works. Always, always, always fight to cultivate and enforce shared culture. It can be unpleasant early on, but it's the only way I know of to build a team that's both happy _and_ productive.

h3. It's the product, stupid

Product should drive engineering, not the other way around. 

h3. Sprints, deadlines, and estimates

This is _really_ important. Say something about this here.

h3. Pick abstractions carefully

Pick the simplest, most concrete possible implementation that solves the customer's problem. Avoid big abstractions -- functions are better than lenses 99.999% of the time. Use simpler language features whenever possible -- an if statement is better than template specialization. Great abstractions feel both simultaneously very abstract in that you can do an enormous number of different things with them, and very concrete in that doing any specific thing is easy and simple. That's why functions and pipes are better abstractions than monads and lenses. Avoid grand beautiful designs -- they're never as grand and as beautiful as you've envisioned them.

h3. Overallocate resources

Here's a resource allocation algorithm:

# Pick the most important priority.
# Allocate as many people to it as the task can handle. Don't be afraid of overallocating, be terrified of underallocating.
# With the remaining people go to step 1.

Overparallelization is death.

h3. Code review everything

It helps a lot.

h3. Fight complexity with all you've got

Linear increases in complexity cause superlinear increases in amount of work to be done. Be careless about complexity, and before you know it your development process will crawl to a halt.

That one engineer you hired to create a new component? Every time it has a bug, it will undoubtedly interact with other components and take up the time of other developers. That API you made slightly more complicated to solve an edge case for a potential (read: imaginary) future customer? Other people will have to spend time learning it, and will inevitably introduce bugs because they misunderstand it (which someone, of course, will have to spend time fixing).

Complexity increases the surface area of your project. In software engineering, large surface area is death. Fight, fight, fight complexity with everything you've got. If you can avoid adding new functionality, fight like hell to keep it out. If you lose that fight, see if you can get 80% of the functionality with 20% of the work. Usually, you can. Fight like hell to do it that way. If you lose _this_ fight, either you've hit the one case in a thousand where complexity is warranted, or, more likely, you should have fought harder.

Less is more. Avoid grand desings. Keep the codebase as small as possible.

h3. Treat big projects with care

Only do one at a time. Have a structure. Peer review everything. Pair program.

h3. Test less code more often

As opposed to more code less often.

h3. Never do large rewrites

It kills you.

